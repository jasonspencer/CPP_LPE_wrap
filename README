This is a pre-alpha release of my CPP_LPE_wrap C++ library.  It is a collection of classes to configure and read Linux Performance Events counters, including a convenient RAII-style counter trigger.  CPP_LPE_wrap is designed to be as lightweight as possible on top of the actual LPE subsystem, which perhaps isn't the most lightweight, so don't expect to profile a few instructions inside a loop, rather all the iterations of the loops (profiling a few instructions is hard enough as it is, considering compiler and CPU re-ordering).

CPP_LPE_wrap is designed to complement the perf command line tool.  perf-record and perf-report work more like a standard debugger annotating the disassembled code with the percentage of event counts at various functions or individual instructions. While perf-stat captures events for the entire run of an executable, and outputs totals at the end. jsplib::PerfEventCount, on the other hand, is inserted into the code, triggered arbitrarily, and makes the event counts available at runtime.

Use cases for CPP_LPE_wrap include the optimization of critical paths, while not capturing events for less critical code. CPP_LPE_wrap could also be used as part of the testing framework, alongside unit testing: it would be possible to test for an increase in cache misses, or page faults, and when code is changed a test fail is triggered if these are found to be different from nominal values.
Another use case would be to build a benchmarking routine into a program that after collecting event data would then optimise the configuration of the program, for example a program may test for page faults to guide the selection of a different data structure to optimise performance to the given hardware, or based on context-switch events recommend a change in the environment's scheduler.

If using hardware counters (PMU), which are limited in number (to about four, but this depends on CPU and event type), it's possible to count one type for a certain section of code, and count another event type in another section, without the need for event multiplexing.


Since this library uses Linux Performance Events, it naturally only works under Linux.

As this is a pre-alpha release you should expect API breakage, renaming and design changes in the future.

There are two main classes: jsplib::perf::PerfEventCount and jsplib::perf::ScopedEventTrigger.
PerfEventCount holds the counter details, and the count, while ScopedEventTrigger is a class that starts and stops the counting when it is created and destroyed.

The basic usage is simple:

using pehs = jsplib::perf::linux_perf_event_counter_t::HWSW_EVENT_T;
jsplib::perf::PerfEventCount perf_counter {
	{ pehs::HW_CACHE_REFERENCES  }, { pehs::HW_CACHE_MISSES }, { pehs::HW_REF_CPU_CYCLES }
};

{
jsplib::perf::ScopedEventTrigger trig { &perf_counter };
// code to profile

}
std::cout << \
perf_counter.getDescription(0) << " : " << perf_counter.getValue( 0 ) << '\t' << \
perf_counter.getDescription(1) << " : " << perf_counter.getValue( 1 ) << \
"\tratio: " << 100.0 * perf_counter.getRatio( 1, 0 ) << " %\n";
std::cout << perf_counter.getDescription ( 2 ) << " : " << perf_counter.getValue( 2 ) << '\n';
std::cout << "Multiplexing scaling factor: " << perf_counter.getLastScaling() << '\n';

To minimise system calls, and therefore the overhead of context switches, all the events passed to the PerfEventCount are initialised as a group - this also means that they can be compared directly, so in the example above the count of HW_CACHE_REFERENCES can be compared against HW_CACHE_MISSES, and the same is true of the example below:

jsplib::perf::PerfEventCount perf_counter {
	{ cev::HW_CACHE_L1D, 	copid::HW_CACHE_OP_READ,	copres::HW_CACHE_RESULT_ACCESS },
	{ cev::HW_CACHE_L1D, 	copid::HW_CACHE_OP_READ,	copres::HW_CACHE_RESULT_MISS },
};

Here we're counting events in the Level 1 data cache only.

// README need more work, including...


There is also jsplib::perf::WallTimeEvent

Things that need work:
1) a nicer interface to map event names to strings
2) less reliance on explicit template paramaters.
